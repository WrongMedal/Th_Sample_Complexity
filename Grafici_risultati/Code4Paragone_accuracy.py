# -*- coding: utf-8 -*-
"""17. Grafico_paragone_accuracy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Wz-hyjwhATk4cA51bAMXmpy3cO3_1_M
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=False)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

def plot_exp_results(rete1, rete2, exp):
    diz_rete = {'A': 1, 'B': 2, 'C': 3}
    diz_esperimento = {1: "Primo", 2: "Secondo", 3: "Terzo", 4: "Quarto", 5: "Quinto"}

    base_path = '/content/drive/MyDrive/Tesi/5. Figure e tabelle'
    experiment_folder = f"{exp}. {diz_esperimento[exp]} esperimento"
    file_name1 = f"Rete{rete1.upper()}.csv"
    file_name2 = f"Rete{rete2.upper()}.csv"
    full_path1 = os.path.join(base_path, experiment_folder, f"{diz_rete[rete1]}. {file_name1}")
    full_path2 = os.path.join(base_path, experiment_folder, f"{diz_rete[rete2]}. {file_name2}")
    output_folder = os.path.dirname(full_path1)

    print(f"üìÇ Caricamento file: {full_path1}")
    try:
        df1 = pd.read_csv(full_path1)
    except FileNotFoundError:
        print("‚ùå File non trovato. Controlla che il percorso e i nomi siano corretti.")
        return

    print(f"üìÇ Caricamento file: {full_path2}")
    try:
        df2 = pd.read_csv(full_path2)
    except FileNotFoundError:
        print("‚ùå File non trovato. Controlla che il percorso e i nomi siano corretti.")
        return

    df1['source'] = f'Modello {rete1}'
    df2['source'] = f'Modello {rete2}'


    df = pd.concat([df1, df2], ignore_index=True)
    for col in ['sample_size', 'test_acc', 'test_loss']:
        df[col] = pd.to_numeric(df[col], errors='coerce')


    df = df.dropna(subset=['layer_structure', 'sample_size', 'test_acc', 'test_loss', 'seed'])
    grouped = df.groupby(['layer_structure', 'sample_size', 'source'])['test_acc'].mean().reset_index()


    plt.figure(figsize=(10, 6))
    layer_structures = sorted(grouped['layer_structure'].unique())
    palette = sns.color_palette("tab10", len(layer_structures))  # Colori distinti per layer_structures
    color_map = {layer: palette[i] for i, layer in enumerate(layer_structures)}

    linestyles = {f'Modello {rete1}': '-', f'Modello {rete2}': '--'}

    for layer in layer_structures:
        for source in [f'Modello {rete1}', f'Modello {rete2}']:
            data = grouped[(grouped['layer_structure'] == layer) & (grouped['source'] == source)]
            if not data.empty:
                plt.plot(data['sample_size'], data['test_acc'],
                         label=f'{layer}' if source == f'Modello {rete1}' else "",  # Mostra solo il primo modello nella legenda
                         linestyle=linestyles[source],
                         color=color_map[layer])

    handles, labels = plt.gca().get_legend_handles_labels()
    plt.legend(handles=handles, labels=labels, title='Colori per \ndimensione degli \nHidden Layers', bbox_to_anchor=(1.05, 1), loc='upper left')

    text = f'Linea continua: Rete {rete1} \nLinea tratteggiata: Rete {rete2}'
    plt.figtext(0.85, 0.45, text, ha='left', fontsize=12, fontweight='bold')

    plt.xlabel('Sample Size')
    plt.ylabel('Test Accuracy')
    plt.title('Test Accuracy vs Sample Size (media su seed)')
    plt.grid(True)
    plt.tight_layout()

    save_path = os.path.join(output_folder, f"Exp{exp}_Rete{rete1.upper()}_VS_Rete{rete2.upper()}.png")
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    print(f"‚úÖ Grafico salvato in: {save_path}")


    plt.show()